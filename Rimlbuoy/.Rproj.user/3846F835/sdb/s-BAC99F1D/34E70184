{
    "collab_server" : "",
    "contents" : "library(Rimlbuoy)\nlibrary(Riops)\n\nwaves0=c(412,443,490,510,555,670, 683)\nband.width0 = rep(10,7)\n\nwaves = c(560,665,681)\nband.width = rep(10,3)\nUSE.MEDIAN = FALSE\n\n\nfname = \"~/MEGA/Arctus/data/2016/IML-4/IML-4_OPTICD_20160927_000319.DAT\"\nraw=read.OPTICD(fname)\n# Find the index falling within the two hours of solar noon\n#####\nGMT_noon =  as.POSIXct(paste(strftime(raw$DateTime, format = \"%Y-%m-%d\")[1],\"12:00:00\", sep = \" \"),\n                       format = \"%Y-%m-%d %H:%M:%S\", tz = \"GMT\")\ndiff.GMT.noon.in.sec <- mean(raw$lon, na.rm = T)/360*24 * 3600\nsolar.noon.time = GMT_noon - diff.GMT.noon.in.sec\n\n# get the first and last indices retained for the processing\nFirst_time = abs(difftime(solar.noon.time - 7200, raw$DateTime))\nFirst_time_ix = which.min(First_time)\nLast_time = abs(difftime(solar.noon.time + 7200, raw$DateTime))\nLast_time_ix = which.min(Last_time)\n\n# Create a vector of good indices\nix.good = First_time_ix:Last_time_ix\nngood = length(ix.good)\n#####\n\n\n# Find the index falling within the one hours of local midnight\n#####\nGMT_midnight =  as.POSIXct(paste(strftime(raw$DateTime, format = \"%Y-%m-%d\")[1],\"04:00:00\", sep = \" \"),\n                           format = \"%Y-%m-%d %H:%M:%S\", tz = \"GMT\")\n\n# get the first and last indices retained for the processing\nFirst_time_night = abs(difftime(GMT_midnight - 3600, raw$DateTime))\nFirst_time_ix_night = which.min(First_time_night)\nLast_time_night = abs(difftime(GMT_midnight + 3600, raw$DateTime))\nLast_time_ix_night = which.min(Last_time_night)\n\n# Create a vector of good indices\nix.good_night= First_time_ix_night:Last_time_ix_night\nngood_night = length(ix.good_night)\n#####\n\n#Make Dark readings\n####\nif (USE.MEDIAN) {\n  dark.read.med.Lu=apply(raw_med$Lu0.86m[ix.good_night,],2,median,na.rm=T)\n}else{\n  dark.read.Lu=apply(raw$Lu0.86m[ix.good_night,],2,median,na.rm=T)\n}\n###\n\n#Make Dark correction\n####\nif (USE.MEDIAN) {\n  dark.med.Lu=raw_med$Lu0.86m[i,]-dark.read.med.Lu\n}else{\n  dark.Lu=raw$Lu0.86m-dark.read.Lu\n}\n###\n# If there is any data within the two hours before or after the Solar Noon proceed, otherwise stop processing\nif (ngood > 1) {\n  # Create matrices or vectors to store the data\n  rho_wn = matrix(NA, ncol=7, nrow=ngood)\n  sunzen = rep(NA, ngood)\n  nLw = matrix(NA, ncol=7, nrow=ngood)\n  bdsh.rrs= matrix(NA, ncol=3, nrow=ngood)\n\n  # Loop on each record between solar noon +/- 2 hours\n  igood.rec = 0\n  for (i in ix.good){\n    igood.rec <- igood.rec + 1 # this in crement is needed to write in the new matrices and vectors\n    print(paste(\"Process :\", raw$DateTime[i]))\n\n    # check if the curent record is complete\n    if (USE.MEDIAN) {\n      complete = (!anyNA(raw_med$Ed0p[i,]) & !anyNA(raw_med$Lu0.86m[i,]))\n    }\n    else complete = (!anyNA(raw$Ed0p[i,]) & !anyNA(raw$Lu0.86m[i,]))\n\n    if (complete) {\n      if (USE.MEDIAN) {\n        res = compute.Rrs.from.buoy(raw$waves,\n                                    raw_med$Ed0p[i,],\n                                    dark.med.Lu[i,],\n                                    raw$DateTime[i],\n                                    raw$lon[i],\n                                    raw$lat[i])\n      } else res = compute.Rrs.from.buoy(raw$waves,\n                                         raw$Ed0p[i,],\n                                         dark.Lu[i,],\n                                         raw$DateTime[i],\n                                         raw$lon[i],\n                                         raw$lat[i])\n\n      rho_wn[igood.rec, ] <- res$rho_wn\n      nLw[igood.rec, ] <- res$nLw\n      sunzen[igood.rec] <- res$sunzen\n\n\n\n      bandshift.fact=unlist(lapply(get.bandshift.coefficient(res$Rrs,waves0,band.width0,waves,band.width),mean,na.rm=T))\n\n      for (i in c(1:length(bandshift.fact))){\n\n       ix.wl=which.min(abs(as.numeric(names(bandshift.fact)[i])-as.numeric(names(res$rho_wn))))\n\n       rho_wn[igood.rec, ix.wl]=rho_wn[igood.rec,ix.wl]*bandshift.fact[i]\n       nLw[igood.rec,ix.wl ]=nLw[igood.rec, ix.wl]*bandshift.fact[i]\n     }\n\n    } else { # If it is not complete the variable will take NA values\n      # The processing will continue with no error\n      print(\"Some data is missing\")\n      print(raw$Ed0p[i,])\n      print(raw$Lu0.86m[i,])\n\n    }\n\n\n    }\n\nreturn(bdsh.rrs)\n}\n",
    "created" : 1476815914359.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3269809193",
    "id" : "34E70184",
    "lastKnownWriteTime" : 1476387893,
    "last_content_update" : 1476387893,
    "path" : "~/MEGA/Arctus/Rcode/test.apply.bandshift.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}