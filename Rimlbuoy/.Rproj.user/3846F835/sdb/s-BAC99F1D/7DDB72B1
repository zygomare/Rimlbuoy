{
    "collab_server" : "",
    "contents" : "#' Get bandshift coefficient to remote sensing reflectance data from\n#' the IML (VIKING) buoys using Zibordi et al (2009) algorithm\n#\n#'\n#' @param Rrs0 : reference remote sensing reflectance that need to be coorected for bandshift (numeric vector).\n#' @param waves0 : reference wavelength (numeric vector).\n#' @param band.width0 : bandwidth of the reference wavelength (numeric vector).\n#' @param waves : target wavelength for the bandshift correction (numeric vector).\n#' @param band.width : bandwidth of a target wavelength (numeric vector).\n#'\n#'\n#' @return Return list of data with the bandshift coefficient The length of\n#' the list is the length of the reference wavelength. Each element have the length of\n#' the sequence center on the targeted wavelength (bandwith dependant).\n#'\n#' @details The correction use the coefficient of the linear regression between\n#' in-situ remote sensing ratio and in-situ IOP measurement of bbp, Ag, A_{nap},\n#' A_{ph} from the 2015 mission on the IML4 buoy. The correction protocol is describe\n#' in Zibordi et al. (2009). The coefficient of the linear regression are used to estimate empirical\n#' modelisation of the IOP to calculate total absorption and total backscattering. Then the ratio of\n#' IOP and reference remote sensing reflectance is used as Eq.7 of Zibordi et al. (2009) to apply the\n#' bandshift corrections.\n#'\n#'   \\deqn{Rrs(\\lambda)= Rrs(\\lambda 0)*\\frac{b_{b}(\\lambda)}{a(\\lambda)+b_{b}(\\lambda)}*\\frac{a(\\lambda 0)+b_{b}(\\lambda 0)}{b_{b}(\\lambda 0)}}{%\n#'   Rrs(\\lambda)= Rrs(\\lambda 0)\n#'   *b_{b}(\\lambda)/(a(\\lambda)+b_{b}(\\lambda))\n#'   *(a(\\lambda 0)+b_{b}(\\lambda 0))/b_{b}(\\lambda 0)}\n#'\n#'\n#'  References :\n#'\n#'\n#'  Zibordi, G., et al., Validation of satellite ocean color primary products at optically complex coastal sites: Northern\n#'  Adriatic Sea, Northern Baltic Proper and Gulf of Finland, Remote Sensing of Environment (2009).\n#'\n#' @examples\n#'\n#' #read an optical data file from IML Buoy\n#' setwd(path.package(\"Rimlbuoy\"))\n#' raw = read.OPTICD(\"data/IML-4_OPTICD_20160501_000320.DAT\")\n#'\n#' #\n#' waves0=c(412,443,490,510,555,670, 683)\n#' band.width0 = rep(10,7)\n#'\n#' waves = c(560,665,681)\n#' band.width = rep(10,3)\n#' ix = 65\n#' rrs = compute.Rrs.from.buoy(raw$waves,raw$Ed0p[ix,], raw$Lu0.86m[ix,], raw$DateTime[ix], raw$lon[ix], raw$lat[ix])\n#'\n#'  bdsfh.coef=get.bandshift.coefficient(rrs$Rrs,waves0,band.width0,waves,band.width)\n#'\n#'\n#'\n#'\n#' @author Thomas Jaegler\n#'\n#' @export get.bandshift.coefficient\n\nget.bandshift.coefficient <- function(Rrs0,\n                                       waves0,\n                                       band.width0,\n                                       waves,\n                                       band.width) {\n\n  load(paste(path.package(\"Rimlbuoy\"),\"/data/coef.Anap.Rdata\",sep=\"\"))\n  load(paste(path.package(\"Rimlbuoy\"),\"/data/coef.Ag.Rdata\",sep=\"\"))\n  load(paste(path.package(\"Rimlbuoy\"),\"/data/coef.Aph.Rdata\",sep=\"\"))\n  load(paste(path.package(\"Rimlbuoy\"),\"/data/coef.bbp.Rdata\",sep=\"\"))\n\n  nb.waves0 = length(waves0)\n\n  if (nb.waves0 != length(Rrs0)){\n    print(\"Rrs0 and waves0 vectors have diffent length!!\")\n    return(0)\n  }\n\n  if (nb.waves0 != length(band.width0)){\n    print(\"band.width0 and waves0 vectors have diffent length!!\")\n    return(0)\n  }\n\n  nb.waves = length(waves)\n  if (nb.waves != length(band.width)){\n    print(\"band.width and waves vectors have diffent length!!\")\n    return(0)\n  }\n\n  ####create empty list for collecting result\n  bdsh.factor=list()\n  ###\n\n  #### Run over each wavelength\n\n  for (i in 1:nb.waves) {\n    print(paste(\"Apply bandshift correction to get Rrs at:\", waves[i]))\n\n    ix.waves0 = which.min(abs(waves[i] - waves0))\n    waves0.vec = (waves0[ix.waves0]-band.width0[ix.waves0]/2):(waves0[ix.waves0]+band.width0[ix.waves0]/2)\n    waves.vec =  (waves[i]-band.width[i]/2):(waves[i]+band.width[i]/2)\n\n    ####section total scattering\n    ####backscattering calculation\n    ix.490=which.min(abs(as.numeric(unname(coef.bbp[1]))-as.numeric(names(Rrs0))))\n    ix.555=which.min(abs(as.numeric(unname(coef.bbp[2]))-as.numeric(names(Rrs0))))\n\n    R_490.555=Rrs0[ix.490]/Rrs0[ix.555]\n    bbp.ref=coef.bbp[4]+coef.bbp[3]*R_490.555\n\n    bbp.sp0=spectral.bbp(waves0.vec,10^as.numeric(unname(bbp.ref)),wl.ref = 532\n                         ,nu=as.numeric(unname(coef.bbp[5])))\n\n    bbp.sp=spectral.bbp(waves.vec,10^as.numeric(unname(bbp.ref)),wl.ref = 532\n                        ,nu=as.numeric(unname(coef.bbp[5])))\n\n    #####water scattering\n    bb.w.sp0=spectral.bw(waves0.vec)\n    bb.w.sp=spectral.bw(waves.vec)\n\n\n    #####total back scattering calculation\n    bb.total.lmbd0=bb.w.sp0+bbp.sp0\n    bb.total.lmbd=bb.w.sp+bbp.sp\n\n    ###\n    ####total absorption section\n\n    ####Anap Absorption\n    ix.490=which.min(abs(as.numeric(unname(coef.Anap[1]))-as.numeric(names(Rrs0))))\n    ix.665=which.min(abs(as.numeric(unname(coef.Anap[2]))-as.numeric(names(Rrs0))))\n\n    R_490.665=Rrs0[ix.490]/Rrs0[ix.665]\n    anap.ref=coef.Anap[4]+coef.Anap[3]*R_490.665\n\n    anap.sp0=spectral.nap(waves0.vec,10^as.numeric(unname(anap.ref)),wl.ref = 412\n                          ,S=as.numeric(unname(coef.Anap[5])))\n\n    anap.sp=spectral.nap(waves.vec,10^as.numeric(unname(anap.ref)),wl.ref = 412\n                         ,S=as.numeric(unname(coef.Anap[5])))\n\n    ######pure water absorption\n    a.w.sp0=spectral.aw(waves0.vec)\n    a.w.sp=spectral.aw(waves.vec)\n\n    ######Yellow absorption\n\n    ix.490=which.min(abs(as.numeric(unname( coef.Ag[1]))-as.numeric(names(Rrs0))))\n    ix.665=which.min(abs(as.numeric(unname( coef.Ag[2]))-as.numeric(names(Rrs0))))\n\n    R_490.665=Rrs0[ix.490]/Rrs0[ix.665]\n    ag.ref= coef.Ag[4]+ coef.Ag[3]*R_490.665\n\n    ag.sp0=spectral.cdom(waves0.vec,10^as.numeric(unname(ag.ref)),wl.ref = 400\n                         ,S=as.numeric(unname(coef.Ag[5])))\n\n    ag.sp=spectral.cdom(waves.vec,10^as.numeric(unname(ag.ref)),wl.ref = 400\n                        ,S=as.numeric(unname(coef.Ag[5])))\n\n\n    ######Phyto absorption\n\n    ix.490=which.min(abs(unique(coef.Aph$waves1)-as.numeric(names(Rrs0))))\n    ix.555=which.min(abs(unique(coef.Aph$waves2)-as.numeric(names(Rrs0))))\n\n    R_490.555=Rrs0[ix.490]/Rrs0[ix.555]\n    aph.ref= coef.Aph[,3]+ coef.Aph[,2]*R_490.555\n\n    ix.wave0.strt.aph=which.min(abs(head(waves0.vec)[1]-coef.Aph$aph.waves))\n    ix.wave0.end.aph=which.min(abs(tail(waves0.vec,n=1)-coef.Aph$aph.waves))\n\n    aph.sp0=10^aph.ref[ix.wave0.strt.aph:ix.wave0.end.aph]\n\n    ix.wave.strt.aph=which.min(abs(head(waves.vec)[1]-coef.Aph$aph.waves))\n    ix.wave.end.aph=which.min(abs(tail(waves.vec,n=1)-coef.Aph$aph.waves))\n\n    aph.sp=10^aph.ref[ix.wave.strt.aph:ix.wave.end.aph]\n\n\n    #####total absorption calculation\n    a.total.lmbd0 = aph.sp0+ag.sp0+a.w.sp0+anap.sp0\n    a.total.lmbd = aph.sp+ag.sp+a.w.sp+anap.sp\n\n\n    ###\n\n\n    bdsh.factor[[i]]=(bb.total.lmbd/(a.total.lmbd0+bb.total.lmbd))*((a.total.lmbd0+bb.total.lmbd0)/bb.total.lmbd0)\n\n  }\n  names(bdsh.factor) = as.character(waves)\n  return(bdsh.factor)\n\n}\n",
    "created" : 1476817148508.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2422829206",
    "id" : "7DDB72B1",
    "lastKnownWriteTime" : 1476816193,
    "last_content_update" : 1476816193,
    "path" : "~/MEGA/Rimlbuoy/R/get.bandshift.coefficient.R",
    "project_path" : "R/get.bandshift.coefficient.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}