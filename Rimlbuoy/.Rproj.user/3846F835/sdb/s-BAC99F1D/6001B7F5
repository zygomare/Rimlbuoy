{
    "collab_server" : "",
    "contents" : "#' Compute remote sensing reflectance from uncorrected optical data from\n#' the IML (VIKING) buoys using Bélanger et al (2016) algorithm\n#'\n#' Apply shadow correction, extrapol from 0.86m to surface and compute Rrs from raw optical data of IML Buoy\n#'\n#'\n#' @param waves Wavelenghts of Ed0 and LuZ\n#' @param Ed0 Spectral irradiance above water\n#' @param LuZ Spectral upwelling radiance measured by the sensor at 0.86m\n#' below sea surface.\n#' @param DateTime A date and time string as POSIXct object\n#' @param lon Longitude in degrees (negative for west),\n#' @param lat Latitude in degrees\n#'\n#' @return Returns a data.frame with sun zenith angle (sunzen),\n#' remote sensing refectances(Rrs),\n#' water leaving radiance (Lw),\n#' normalized water leaving radiance (nLw),\n#'  and reflectance (rhown)\n#'\n#'@details The data processing includes mainly two corrections.\n#'First the upwelling radiance is corrected for shadow effect using\n#'an empirical algorithm developped at the IML4 site during summer 2015.\n#'The algorithm is detailed in Bélanger et al\n#'(manuscript in preparation, June 2016).\n#'\n#'\n#'\n#' @examples\n#'\n#' #read an optical data file from IML Buoy\n#'setwd(path.package(\"Rimlbuoy\"))\n#'raw = read.OPTICD(\"data/IML-4_OPTICD_20160501_000320.DAT\")\n#'\n#' # select an indice. here 65 is 16:30 GMT or 12:30 t local time\n#'ix = 65\n#'rrs = compute.Rrs.from.buoy(raw$waves,raw$Ed0p[ix,], raw$Lu0.86m[ix,], raw$DateTime[ix], raw$lon[ix], raw$lat[ix])\n#'\n#' # plot the Rrs spectrum\n#'plot(raw$waves, rrs$Rrs, type=\"l\", main=raw$DateTime[ix], ylim=c(0,max(rrs$Rrs, na.rm=TRUE)),sub=paste(\"Latitude:\", signif(raw$lat[ix],6), \"   Longitude:\", signif(raw$lon[ix],6)), xlab=\"Wavelength\")\n#'\n#'\n#' @export compute.Rrs.from.buoy\n#'\ncompute.Rrs.from.buoy <- function (waves,Ed0, LuZ, DateTime, lon, lat) {\n\n  # extract information from DateTime and compute sun zenith angle\n  julian.day <- as.numeric(format(DateTime, format = \"%j\"))\n  month <- as.numeric(format(DateTime, format = \"%m\"))\n  day <- as.numeric(format(DateTime, format = \"%d\"))\n  time.poslt <- as.POSIXlt(DateTime)\n  ftime <- time.poslt$hour + time.poslt$min/60 + time.poslt$sec/3600\n  sunzen = possol(month,day,ftime,lon,lat)[1]\n\n  # compute Band ratios from uncorrected reflectance\n  rrs_uncor = LuZ/Ed0\n  R0 = rrs_uncor[1]/rrs_uncor[5]\n  R1 = rrs_uncor[2]/rrs_uncor[5]\n  R2 = rrs_uncor[3]/rrs_uncor[5]\n  R3 = rrs_uncor[4]/rrs_uncor[5]\n  R4 = rrs_uncor[7]/rrs_uncor[6]\n  R.lee = (rrs_uncor[2]+rrs_uncor[3])/(rrs_uncor[5]+5*rrs_uncor[6]/rrs_uncor[3]*rrs_uncor[6])\n\n\n  # Use a MRL coefficient to compute diffuse attenuation of LuZ as derived from Bélanger et al in prep\n  K = rep(NA, length(waves))\n  kappa = mr.coeff.klu2m.r2.adj\n\n\n  for (i in 1:7) {\n    if (colnames(kappa)[i] == \"xi\") R = R.lee\n    if (colnames(kappa)[i] == \"412/555\") R = R0\n    if (colnames(kappa)[i] == \"443/555\") R = R1\n    if (colnames(kappa)[i] == \"490/555\") R = R2\n    if (colnames(kappa)[i] == \"510/555\") R = R3\n    if (colnames(kappa)[i] == \"683/670\") R = R4\n\n    K[i] =    10^(kappa[1,i] +\n                    kappa[2,i]*log10(R) +\n                    kappa[3,i]*sunzen)\n  }\n\n\n  # calculate the fraction of diffuse sky using G&C1990 model as implemented in COPS package\n  ix490 = which.min(abs(waves-490))\n  visibility <- 25\n  GreggCarder.d = GreggCarder.data()\n  egc <- GreggCarder.f(julian.day, lon, lat , sunzen, lam.sel = waves, Vi=visibility)\n  ratio = egc$Ed[ix490]*100/Ed0[ix490]\n\n  # Reduced progressively the visilibity to obtain the rigth\n  while (ratio > 1.05 & visibility > 0.5) {\n    egc <- GreggCarder.f(julian.day, lon, lat, sunzen,lam.sel = waves, Vi=visibility)\n    ratio = egc$Ed[ix490]*100/Ed0[ix490]\n    visibility = visibility - 0.5\n  }\n  Ed0.f = egc$Edif/egc$Ed\n\n\n  # calculate epsilon from empirical relationships\n  c_coef = mr.coeff.epsilon.r2.adj\n\n  epsilon <- rep(NA, length(waves))\n  for (i in 1:7) {\n\n    if (colnames(c_coef)[i] == \"xi\") R = R.lee\n    if (colnames(c_coef)[i] == \"412/555\") R = R0\n    if (colnames(c_coef)[i] == \"443/555\") R = R1\n    if (colnames(c_coef)[i] == \"490/555\") R = R2\n    if (colnames(c_coef)[i] == \"510/555\") R = R3\n    epsilon[i] =\n      c_coef[1,i] +\n      c_coef[2,i] * log10(R) +\n      c_coef[3,i] * Ed0.f[i] +\n      c_coef[4,i] * sunzen\n  }\n\n  # corect LuZ for shadow\n  LuZ.corrected = LuZ / (1 - unlist(epsilon))\n\n  # Extrapol corrected LuZ to surface\n  Lu.0m = LuZ.corrected/exp(-K*0.86)\n\n  # compute Rrs\n  Lw = 0.54 * Lu.0m\n  Rrs = Lw / Ed0\n\n  # compute normalised water  reflectance\n  rho_wn = pi*Rrs\n\n  # compute normalised water leaving radiance\n  # get extraterestrial irradiance at TOA from Thuillier\n  F0 = etirr(waves)\n  nLw = F0 * Rrs\n\n  return(list(sunzen=sunzen,\n              Rrs=Rrs,\n              Lw=Lw,\n              nLw=nLw,\n              rho_wn=rho_wn))\n\n}\n",
    "created" : 1476889408571.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "247605308",
    "id" : "6001B7F5",
    "lastKnownWriteTime" : 1476723217,
    "last_content_update" : 1476723217,
    "path" : "~/MEGA/Rimlbuoy/R/compute.Rrs.from.buoy.R",
    "project_path" : "R/compute.Rrs.from.buoy.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}