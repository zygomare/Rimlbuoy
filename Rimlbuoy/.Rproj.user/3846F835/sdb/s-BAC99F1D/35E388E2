{
    "collab_server" : "",
    "contents" : "#' Generate an ASCII file for the MERMAID data base containing\n#' dark corrected remote sensing reflectance and water leaving radiance from the\n#' IML buoy.\n#'\n#' This routine takes two files coming from the buoys as input, then apply\n#' a number of quality control check and compute Rrs following the method detailed\n#' in Belanger et al.\n#'\n#' @param OPTICD_fname Name of the OPTICD data file IML buoy containing\n#' mean and standard deviation for each OCR channels.\n#' @param outputdir Path for the ouptut directory where the\n#' results will be saved in ASCII format.\n#' @param Tilt_threshold is the threshold for maximum tilt angle tolerance.\n#' Default value is 10.\n#' @param USE.MEDIAN is a logical parameter indicating whether the Rrs is\n#' cumputed using median values stored OCR_MED files. If TRUE, the file name\n#' of the output will begin by rrs_med_.\n#' Default is FALSE.\n#' @param PI : pi full name\n#' @param PI_Email : pi email adress\n#' @param land_dist_IS : In-situ measurement distance to the land\n#' @param PQC : Processing quality control from MERMAID (see MERMAID data format report from ACRI-ST)\n#' @param MQC : Measurement Quality Control from MERMAID (see MERMAID data format report from ACRI-ST)\n#' @param USE.BANDSHIFT.COEF is a logical parameter indicating whether the bandshift coefficient must\n#' be used if TRUE the following parameter are needed (band.width,waves2,band.width2).\n#' Default is TRUE.\n#' @param band.width : bandwidth of the reference wavelength (numeric vector).\n#' @param waves2 : target wavelength for the bandshift correction (numeric vector).\n#' @param band.width2 : bandwidth of a target wavelength (numeric vector).\n#' @details This function reads the data file provided as input,\n#' apply quality control checks and then compute Rrs using \\code{\\link{compute.Rrs.from.buoy}}.\n#' Next ìf USE.BANDSHIFT.COEF is true, the bandshift correction is apply to nlw and rho_w. Then the\n#' flags for coefficient of variation (<20%) and tilt (<10°) are identified and excluded. Then the final\n#' data frame is formated with MERMAID header.\n#'\n#'\n#' @return It writes an csv file names rrs_DATE.csv (or rrs_med_DATE.csv) and\n#' returns a data frame in the command line.\n#'\n#' @examples\n#'#Define file names\n#'setwd(path.package(\"Rimlbuoy\"))\n#'pathwd=\"\"data/\"\"\n#'fnames = list.files(pathwd,full.names = T)\n#'fn=fnames[grep(\"OPTICD\",fnames)]\n#'\n#'#Define threshold for tilt flag\n#'Tilt_threshold = 10\n#'band.width=rep(10,7)\n#'waves2= c(560,665,681)\n#'band.width2 = rep(10,3)\n#'PI=\"Simon_Belanger\"\n#'PI_Email =\"sbe@arctus.ca\"\n#'land_dist_IS = 20\n#'PQC = \"P000010000\"\n#'MQC=\"M110111001101020200\"\n#'\n#\n#'\n#'#Define output dir\n#' output_dir_data=\"./data/\"\n#'\n#'#Run write.to.MERMAID\n#'res = write.to.MERMAID(OPTICD_fname=fn,outputdir=output_dir_data,Tilt_threshold=Tilt_threshold)\n#'res.med = write.to.MERMAID(OPTICD_fname=fn,outputdir=output_dir_data,Tilt_threshold=Tilt_threshold,USE.MEDIAN=T)\n#'str(res)\n#'\n#' @export write.to.MERMAID\n#'\n#' @author Thomas Jaegler modified by Simon Belanger\n\nwrite.to.MERMAID <- function(OPTICD_fname,\n                                outputdir,\n                                Tilt_threshold=10,\n                                USE.MEDIAN=FALSE,\n                                PI,\n                                PI_Email,\n                                land_dist_IS,\n                                PQC,\n                                MQC,\n                                USE.BANDSHIFT.COEF=TRUE,\n                                band.width,\n                                waves2,\n                                band.width2) {\n\n  # Extract information from the file name\n  base = basename(OPTICD_fname)\n  inpath = dirname(OPTICD_fname)\n  BuoyID = paste(str_sub(base,1,3),str_sub(base,5,5),sep=\"\")\n  idexdat= str_sub(base,13,28)\n  #######\n\n  # Skip missing function between R3.02 and R3.03\n  anyNA <- function(x) any(is.na(x))\n  #######\n\n\n  # Read file\n  raw = read.OPTICD(OPTICD_fname)\n\n  if (USE.MEDIAN) { # This will allows the possibility to process archived data when MED was not available\n    OCR_MED_fname = paste(inpath,\"/\",BuoyID, \"_OCR_MED\",idexdat,\".DAT\",sep=\"\")\n    raw_med = read.OCR_MED(OCR_MED_fname)\n  }\n\n  ######\n\n  # Detect if buoy coordinate is present if not define coordinate\n  #####\n  if (is.na(as.numeric(raw$lat))){\n    if (BuoyID == \"IML4\"){\n      raw$lat= rep(convert_str_coord(\"48° 40.002' N\"),length(raw$DOY))\n      raw$lon = rep(convert_str_coord(\"68° 34.998' O\"),length(raw$DOY))\n    }else if(BuoyID == \"IML6\"){\n      raw$lat = rep(convert_str_coord(\"47° 46.998' N\"),length(raw$DOY))\n      raw$lon = rep(convert_str_coord(\"64° 1.998' O\"),length(raw$DOY))\n    }else if(BuoyID == \"IML10\"){\n      raw$lat= rep(convert_str_coord(\"48° 0' N\"),length(raw$DOY))\n      raw$lon= rep(convert_str_coord(\"60° 30' O\"),length(raw$DOY))\n    }\n  } else {\n    # SB: Il faudrait en mettre plus des print() et les sauvegarder dans un fichier .log\n    # a faire\n    print(\"GPS OK\")\n  }\n\n  #same for med\n  if (USE.MEDIAN) { # This will allows the possibility to process archived data when MED was not available\n    if (is.na(as.numeric(raw$lat))){\n      if (BuoyID == \"IML4\"){\n        raw$lat= raw_med$lat = rep(convert_str_coord(\"48° 40.002' N\"),length(raw$DOY))\n        raw$lon =  raw_med$lon = rep(convert_str_coord(\"68° 34.998' O\"),length(raw$DOY))\n      }else if(BuoyID == \"IML6\"){\n        raw$lat= raw_med$lat = rep(convert_str_coord(\"47° 46.998' N\"),length(raw$DOY))\n        raw$lon = raw_med$lon = rep(convert_str_coord(\"64° 1.998' O\"),length(raw$DOY))\n      }else if(BuoyID == \"IML10\"){\n        raw$lat= raw_med$lat = rep(convert_str_coord(\"48° 0' N\"),length(raw$DOY))\n        raw$lon = raw_med$lon = rep(convert_str_coord(\"60° 30' O\"),length(raw$DOY))\n      }\n    } else {\n      # SB: Il faudrait en mettre plus des print() et les sauvegarder dans un fichier .log\n      # a faire\n      print(\"GPS OK\")\n    }\n\n  }\n  #####\n\n  # Find the index falling within the two hours of solar noon\n  #####\n  GMT_noon =  as.POSIXct(paste(strftime(raw$DateTime, format = \"%Y-%m-%d\")[1],\"12:00:00\", sep = \" \"),\n                         format = \"%Y-%m-%d %H:%M:%S\", tz = \"GMT\")\n  diff.GMT.noon.in.sec <- mean(raw$lon, na.rm = T)/360*24 * 3600\n  solar.noon.time = GMT_noon - diff.GMT.noon.in.sec\n\n  # get the first and last indices retained for the processing\n  First_time = abs(difftime(solar.noon.time - 7200, raw$DateTime))\n  First_time_ix = which.min(First_time)\n  Last_time = abs(difftime(solar.noon.time + 7200, raw$DateTime))\n  Last_time_ix = which.min(Last_time)\n\n  # Create a vector of good indices\n  ix.good = First_time_ix:Last_time_ix\n  ngood = length(ix.good)\n  #####\n\n\n  # Find the index falling within the one hours of local midnight\n  #####\n  GMT_midnight =  as.POSIXct(paste(strftime(raw$DateTime, format = \"%Y-%m-%d\")[1],\"04:00:00\", sep = \" \"),\n                             format = \"%Y-%m-%d %H:%M:%S\", tz = \"GMT\")\n\n  # get the first and last indices retained for the processing\n  First_time_night = abs(difftime(GMT_midnight - 3600, raw$DateTime))\n  First_time_ix_night = which.min(First_time_night)\n  Last_time_night = abs(difftime(GMT_midnight + 3600, raw$DateTime))\n  Last_time_ix_night = which.min(Last_time_night)\n\n  # Create a vector of good indices\n  ix.good_night= First_time_ix_night:Last_time_ix_night\n  ngood_night = length(ix.good_night)\n  #####\n\n  #Make Dark readings\n  ####\n  if (USE.MEDIAN) {\n    dark.read.med.Lu=apply(raw_med$Lu0.86m[ix.good_night,],2,median,na.rm=T)\n  }else{\n    dark.read.Lu=apply(raw$Lu0.86m[ix.good_night,],2,median,na.rm=T)\n  }\n  ###\n\n  #Make Dark correction\n  ####\n  if (USE.MEDIAN) {\n    dark.med.Lu=raw_med$Lu0.86m[i,]-dark.read.med.Lu\n  }else{\n    dark.Lu=raw$Lu0.86m-dark.read.Lu\n  }\n  ###\n\n  # If there is any data within the two hours before or after the Solar Noon proceed, otherwise stop processing\n  if (ngood > 1) {\n    # Create matrices or vectors to store the data\n    rho_wn = matrix(NA, ncol=7, nrow=ngood)\n    sunzen = rep(NA, ngood)\n    nLw = matrix(NA, ncol=7, nrow=ngood)\n\n\n    # Loop on each record between solar noon +/- 2 hours\n    igood.rec = 0\n    for (i in ix.good){\n      igood.rec <- igood.rec + 1 # this in crement is needed to write in the new matrices and vectors\n      print(paste(\"Process :\", raw$DateTime[i]))\n\n      # check if the curent record is complete\n      if (USE.MEDIAN) {\n        complete = (!anyNA(raw_med$Ed0p[i,]) & !anyNA(raw_med$Lu0.86m[i,]))\n      }\n      else complete = (!anyNA(raw$Ed0p[i,]) & !anyNA(raw$Lu0.86m[i,]))\n\n      if (complete) {\n        if (USE.MEDIAN) {\n          res = compute.Rrs.from.buoy(raw$waves,\n                                      raw_med$Ed0p[i,],\n                                      dark.med.Lu[i,],\n                                      raw$DateTime[i],\n                                      raw$lon[i],\n                                      raw$lat[i])\n        } else res = compute.Rrs.from.buoy(raw$waves,\n                                           raw$Ed0p[i,],\n                                           dark.Lu[i,],\n                                           raw$DateTime[i],\n                                           raw$lon[i],\n                                           raw$lat[i])\n\n        rho_wn[igood.rec, ] <- res$rho_wn\n        nLw[igood.rec, ] <- res$nLw\n        sunzen[igood.rec] <- res$sunzen\n\n      ######Make bandshift correction\n\n        if (USE.BANDSHIFT.COEF) {\n          bandshift.fact=unlist(lapply(get.bandshift.coefficient(res$Rrs,raw$waves,band.width,waves2,band.width2),mean,na.rm=T))\n\n          for (i in c(1:length(bandshift.fact))){\n\n            ix.wl=which.min(abs(as.numeric(names(bandshift.fact)[i])-as.numeric(names(res$rho_wn))))\n            ix.wl.thullier=which.min(abs(as.numeric(names(bandshift.fact)[i])-thuillier.completed.by.AM0AM1$wave))\n            ix.wl0.thullier=which.min(abs(as.numeric(names(res$rho_wn)[ix.wl])-thuillier.completed.by.AM0AM1$wave))\n\n            ratio.thuillier=(thuillier.completed.by.AM0AM1$F0[ix.wl.thullier]/thuillier.completed.by.AM0AM1$F0[ix.wl0.thullier])\n\n            rho_wn[igood.rec, ix.wl]=rho_wn[igood.rec,ix.wl]*bandshift.fact[i]\n            nLw[igood.rec,ix.wl ]=nLw[igood.rec, ix.wl]*ratio.thuillier*bandshift.fact[i]\n          }\n\n        }else{\n          print(\"DO NOT apply bandshift coefficient\")\n        }\n\n      } else { # If it is not complete the variable will take NA values\n        # The processing will continue with no error\n        print(\"Some data is missing\")\n        print(raw$Ed0p[i,])\n        print(raw$Lu0.86m[i,])\n\n      }\n    }\n\n    #####Calculate coefficient of variation for Ed and define new variable for Ed_flag\n    Ed0p.cv <- raw$Ed0p.sd[ix.good,]/raw$Ed0p[ix.good,]\n    Ed0p.cv.flag <- Ed0p.cv > 0.2\n    #######\n\n    ######Calculate coefficient of variation for Lu and define new variable for Lu_flag\n    Lu0.86m.cv <- raw$Lu0.86m.sd[ix.good,]/dark.Lu[ix.good,]\n    Lw.cv.flag <- Lu0.86m.cv > 0.2 | is.na(Lu0.86m.cv)\n    ###################\n\n    ######### Detect tilt above threshold and create variable flag\n    tilt.flag <- raw$tilt[ix.good] > Tilt_threshold\n    ###########\n\n    #make some necesary Header ID for Mermaid submission\n    MATCHUP_ID = paste(BuoyID,\"_0\",seq(1,length.out = length(raw$DateTime[ix.good])),\"_\",idexdat,sep=\"\")\n    site = rep(BuoyID,length(raw$DateTime[ix.good]))\n    PI=rep(PI,length(raw$DateTime[ix.good]))\n    PI_Email =rep(PI_Email ,length(raw$DateTime[ix.good]))\n    land_dist_IS = rep(land_dist_IS,length(raw$DateTime[ix.good]))\n    waves.fin=raw$waves\n\n\n    if (nchar(PQC) == 10){\n    PQC = rep(PQC,length(raw$DateTime[ix.good]))\n    }else{\n      print(\"Something wrong with PQC flags see Mermaid data format.\")\n    }\n\n    if (nchar(MQC) == 19){\n    MQC=  rep(MQC,length(raw$DateTime[ix.good]))\n    }else{\n      print(\"Something wrong with MQC flags see Mermaid data format.\")\n    }\n\n    # Add new data and flags to the data frame\n    result.df=data.frame(MATCHUP_ID,site,PI,PI_Email, # split the date and time for the\n                         raw$lat[ix.good],\n                         raw$lon[ix.good],\n                         format(raw$DateTime[ix.good], format=\"%Y%m%dT%H%M%SZ\"),\n                         PQC,\n                         MQC,\n                         land_dist_IS,\n                         sunzen,\n                         Ed0p=raw$Ed0p[ix.good,],\n                         nLw,\n                         rho_wn,\n                         raw$tilt[ix.good],\n                         raw$FCHL[ix.good],\n                         raw$FDOM[ix.good],\n                         apply(Ed0p.cv.flag,2,as.numeric), # the flags are put at the end\n                         apply(Lw.cv.flag,2,as.numeric),\n                         as.numeric(tilt.flag))\n\n    if (USE.BANDSHIFT.COEF){\n\n\n      for (i in c(1:length(bandshift.fact))){\n        ix.wl=which.min(abs(waves2[i]-raw$waves))\n        waves.fin[ix.wl]=waves2[i]\n      }\n    # add names to the data frame # this is the most complicated part of the code!\n    colnames(result.df) = c(\"MATCHUP_ID\",\"Site\",\"PI\",\"PI(s)_Email\",\"Lat_IS\", \"Lon_IS\",\n                            \"TIME_IS\",\n                            \"PQC\",\n                            \"MQC\",\n                            \"land_dist_IS\",\n                            \"thetas IS\",\n                            paste(\"Es_IS\",raw$waves,sep=\"_\"),\n                            paste(\"LwN_IS\",waves.fin,sep=\"_\"),\n                            paste(\"rho_w_IS\",waves.fin,sep=\"_\"),\n                            \"tilt\",\n                            \"Fluor_chla_IS\",\n                            \"Fluor_cdom_IS\",\n                            paste(\"Es_IS.cv.flag\",waves.fin,sep=\"_\"),\n                            paste(\"LwN_IS.cv.flag\",waves.fin,sep=\"_\"),\n                            \"tilt_flag\"\n    )\n\n    }else{\n      colnames(result.df) = c(\"MATCHUP_ID\",\"Site\",\"PI\",\"PI(s)_Email\",\"Lat_IS\", \"Lon_IS\",\n                              \"TIME_IS\",\n                              \"PQC\",\n                              \"MQC\",\n                              \"land_dist_IS\",\n                              \"thetas IS\",\n                              paste(\"Es_IS\",raw$waves,sep=\"_\"),\n                              paste(\"LwN_IS\",waves.fin,sep=\"_\"),\n                              paste(\"rho_w_IS\",waves.fin,sep=\"_\"),\n                              \"tilt\",\n                              \"Fluor_chla_IS\",\n                              \"Fluor_cdom_IS\",\n                              paste(\"Es_IS.cv.flag\",raw$waves,sep=\"_\"),\n                              paste(\"LwN_IS.cv.flag\",raw$waves,sep=\"_\"),\n                              \"tilt_flag\"\n      )\n  }\n\n\n\n    # Select non-flagged data's\n    result.df.index=which(result.df==1,arr.ind = T)\n    if( length(result.df.index)==0){\n      result.df.MERMAID=result.df[,c(1:32)]\n    }else{\n    result.df.MERMAID=result.df[-unique(result.df.index[,1]),c(1:32)]\n    }\n    ####\n\n    #\n    if (length(row.names(result.df.MERMAID)) == 0){\n      print(\"NO data in the time frame\")\n      return(0)\n    }else{\n    }\n    # Write the data frame in an ASCII file\n    if (USE.MEDIAN) {\n      outfile <- paste(outputdir, \"/rrs_med_\", BuoyID,idexdat, \".csv\", sep = \"\")\n    }else outfile <- paste(outputdir, \"/rrs_\",  BuoyID,idexdat, \".csv\", sep = \"\")\n    write.table(result.df.MERMAID, file=outfile, sep = \";\", row.names = F, quote = F)\n\n    return(result.df.MERMAID)\n  }else {\n    print(\"NO data in the time frame\")\n    return(0)\n  }\n}\n\n",
    "created" : 1476717136435.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1415241228",
    "id" : "35E388E2",
    "lastKnownWriteTime" : 1476903746,
    "last_content_update" : 1476903746,
    "path" : "~/MEGA/Rimlbuoy/R/write.to.MERMAID.R",
    "project_path" : "R/write.to.MERMAID.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}